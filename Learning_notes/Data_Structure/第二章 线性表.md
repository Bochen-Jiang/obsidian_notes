# 2.1 线性表的定义及ADT

规范的来讲，线性结构是n（n >= 0)个结点的有穷序列（$a_1,a_2,a_3,...$ ）。$a_0$称为起始节点，$a_n$ 称为终端节点，对于任意一对相邻节点$a_i$和$a_{i+1}$ ,$a_i$称为$a_{i+1}$的直接前驱，$a_{i+1}$称为$a_i$ 的直接后继。


线性表是**处理线性结构**的数据结构。数据元素的个数称为线性表的长度，简称为表长。


根据线性结构的特点，线性表的基本运算分为以下几种：
- **创建一个空线性表create。
- **删除线性表中的所有数据元素clear。
- **求线性表的长度length。
- **在第i个位置插入一个元素insert(i,x)使得线性表$（a_0,a_1,a_2,...,a_{i-1},a_i,...,a_{n-1}）$变成$（a_0,a_1,a_2,...,a_{i-1},x,a_i,...,a_{n-1}）$，参数i的合法取值范围是0到n。
- **删除第i个位置的元素remove(i,x),使得线性表$（a_0,a_1,a_2,...,a_{i-1},a_i,...,a_{n-1}）$变成$（a_0,a_1,a_2,...,a_{i-1},a_{i+1}...,a_{n-1}）$ 参数i的合法取值范围是0到n－1
- **搜索元素search（x），检查某个元素，在线性表中是否出现，并返回x的位置。
- **返回线性表中第i个数据元素的值visit（i）。
- **按序访问线性表的每一个数据元素traverse。**

> **==注意！==**
> ==在计算机科学中，线性表等数据结构里元素位置的索引通常从0开始。==
> ==假设数组{1,3,5,6,7,8,4}，那么visit（5）应当为8！==



 ```c++
 elemType是一个类型参数，在实例化类时指定具体的数据类型，如int 、 double  或自定义类等。
template <class elemType>
class list 
{
	public:
			//删除线性表中所有的元素
			virtual void clear()=0;
			//求线性表的长度
			virtual int length() const = 0;
			//在i个位置上插入一个元素
			virtual void insert(int i,const elemType &x)=0;
			//删除某个元素
			virtual void remove(int i) = 0;
			//搜索某个元素x在线性表中是否出现
			virtual int search(const elemaType &x) const = 0;
			//返回线性表中第i个元素的值
			virtual elemType visit(int i) const = 0;
			//按序访问线性表的每一数据元素
			virtual void traverse() const = 0;
			virtual ～list();
/*
virtual void clear()=0; ：这是一个纯虚函数，用于删除线性表中的所有数据元素。 virtual  关键字表示该函数可以在派生类中被重写， =0  表示这是一个纯虚函数，即没有函数体，派生类必须实现该函数。
 
virtual int length() const = 0; ：纯虚函数，用于获取线性表的长度， const  表示该函数不会修改类的成员变量。
 
 virtual void insert(int i, const elemType &x)=0; ：在第  i  个位置插入一个元素  x ， const elemType &x  使用引用传递参数，提高效率且避免不必要的拷贝。
 
-  virtual void remove(int i)=0; ：删除第  i  个位置的元素。
 
-  virtual int search(const elemType &x) const = 0; ：搜索元素  x  在线性表中是否出现，返回出现的位置或特定标识（如 -1 表示未找到）。
 
-  virtual elemType visit(int i) const = 0; ：返回线性表中第  i  个数据元素的值。
 
-  virtual void traverse() const = 0; ：按顺序访问线性表的每一个数据元素。*/
```



# 线性表的顺序实现



线性表中元素之间的关系是线性的，而内存单元之间的关系也是线性的。因此，线性表的顺序实现只需要将元素之间的关系映射到内存之间的关系。


## 2.2.1 顺序表的存储实现

线性表的顺序实现，就是将线性表的数据元素存储在一块连续的空间，用储存位置反映数据元素之间的关系。

**一般来说，数组是所有语言所支持的数据类型，并且其具有天然的线性结构，因此，只需要将两者一一对应即可，将顺序表的第i位存放于数组的第i个下标变量的值，那么他的直接前驱就放在第$（i-1）$个位置，而他的直接后继存在于第$i+1$下标变量中。

- 线性表经常需要执行插入和删除操作，因此需要足够的空间，数组的规模称为容量。
- 但是在设计的过程中，不一定知道具体的规模，因此，最好使用动态数组，需要两个变量：指向数组起始指针和数组的规模。


![[51688b88760625ca325482c38cc0c300_MD5.jpeg]]

- 其中$a_0$是不储存数据的，用来某些特殊的用途，initSize是数组的大小，len是元素的个数，有如下关系：$$maxSize = initSize - 1$$
```c++
#include <isotream>
#define INITSIZE 100
using namespace std;

class illegalSize{};
class outOfBound{};

template<class elemType>
class seqList {
	private:
		elemType *elem;
		int len;
		int maxSize;
		void doubelSpace();
	public:
		seqList (int size=INITSIZE);//initalize the seqList 
		//if the list is blank, return true,otherwise false 
		bool isEmpty()const {return len == maxSize;}
		int length()const {return len;}//return the length of the list 
		elemType get(int i)const ;//return  NO.i element 
		//find the element values 'e' ,or return 0;
		int find(const elemType &e) const;

		//insert a new element between NO.i and NO.(i+1)
		void insert(int i,const elemType &e);
		/*if the No.i element exists,delete it and put its value into the 
		space where e points.*/
		void remove(int i,elemType &e );
	
		void clear() {len = 0;}//clear the list make it a null space 
		~seqList() {delete []elem;}
		//delete the list and free the dynamic array.	
		}
```

## 2.2.2 顺序表基本操作的实现

### 1.查找操作

[[8b45889c8a2491e23b9a1bb3971255fb_MD5.jpeg|Open: Pasted image 20250306205657.png]]
![[8b45889c8a2491e23b9a1bb3971255fb_MD5.jpeg]]
- 对于上述的数组，数组的第一个元素并没有存储任何东西，那么在查找前先将需要查找的元素放在elem[0]中，并将其称为哨兵单元。
- 开始查找后，计算机会从最后一个元素开始，如果成功在elem[0]之前查找到，则直接停止，如果没有，那么查找也会在elem[0]停止，使得不会下标越界。
- 时间复杂度为:$$\frac{1}{n}\sum_{i=n}^1(n-i+1) = \frac{1}{n}·\frac{n(n+1)}{2}=\frac{n+1}{2}$$因此为$O(n)$


### 2.插入操作

![[5b986147a3da4c2a47ca809f6505db51_MD5 1.jpeg]]
- 假如在第三个位置插入元素，那么接下来每个元素都往后移动一位，一共移动了4个（n-i+1）数字。
- 所以在（n+1）个位置等概率插入的情况下，元素的平均移动次数：$$\frac{1}{n+1}\sum_{i=n+1}^1(n-i+1)=\frac{1}{n+1}·\frac{n(n+1)}{2}=\frac{n}{2}$$
- 有一种“分期付款法”，从空表开始到n+1次插入时，遇到一次DoubleSpace,将所有的元素复制到一个新的大数组里，这n次复制操作，平均到n次插入操作中，所以时间消耗为$O(1)$总共的时间复杂度为$O(n)$
- ==注意！==
>移动时，一定要从最后一位开始移动，否则将会把后面所有的元素变成同一个元素（即刚开始移动的那个元素）


### 3. 删除操作


![[7d00d72f3b443f7d90b25a2954125dc2_MD5.jpeg]]

- 删除的操作过程：
将需要删除的元素先读出（存入主调函数供使用）之后，将所有的元素前移一位，必须从删除元素的直接后继元素开始。一共需要移动$n-i$个元素。
- 平均移动速度：$$\frac{1}{n}\sum_{i=1}^{n}(n-i)=\frac{n-1}{2}$$


## 2.3线性表的链式储存结构

通过对线性表的认识，有着频繁插入或删除操作的序列来说，顺序表显然不是最合适的。因此引入了链式储存结构存储线性表。

**具体解释：
就是将所有的元素的“尾巴”上加上一个指针，这个指针可以指向下一个元素，而下一个元素的位置随意不一定与上一个元素连续。

- 这种线性表我们称为**链表**。
- 对于存储单元中由元素值和指针组成的结构体变量（类的对象）称为结点。
- 在C++中，添加结点，删除结点分别需要**动态申请空间**和**释放结点空间**，即new和delete
- 在具体实现时，通常在首结点之前额外增加一个相同类型的特殊结点，称为头结点。头节点**并不储存线性表中的元素。**
- 同时设置一个头指针head来指向头结点。


#### 链表的类型

(1) 单链表

每个结点只附加一个指针字段，指向直接后继结点，**如果最后一个指针指向头结点，则**称为==单向循环链表==。

![[5c0961979ce57c8a9fb049fb6e45d5fe_MD5.jpeg]]

（2）双链表
- 每个结点附加了两个指针字段，一个指向直接前驱结点，一个指向直接后继节点。
- **头节点和尾结点都不储存实际元素
![[2aea973c9c67a7641ff55d6105c428ca_MD5.jpeg]]


（3）空链表
![[Pasted image 20250307142607.png]]



### 2.3.1 单链表

注意：
	头指针指向头节点，头节点不是线性表中的一部分，它的指针字段next给出了首结点的地址，线性表最后一个节点,指针字段next的值为NULL

### 2.3.2 单链表基本操作的实现
1. 插入操作
2. 删除操作
3. 查找操作
[[单链表的基本操作.canvas]]
4. 其他操作





### 2.3.3 单向循环链表


![[Pasted image 20250307172741.png]]
